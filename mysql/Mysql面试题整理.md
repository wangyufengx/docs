# Mysql面试题整理

1. 数据库三大范式
- 第一范式： 每一列（属性）都不可再分。（原子性）
- 第二范式： 在第一范式的基础上，非主属性非部分依赖于主属性。（换句话说，第一范式消除了非主属性对主属性的部分函数依赖的就是第二范式）
- 第三范式： 在第二范式的基础上，属性不依赖于其他非主属性。（换句话说，第二范式消除了非主属性对主属性的传递函数依赖的就是第三范式）

2. MySQL逻辑架构

   ```
   											客户端
   											  |
   											  |
   											  |
   											连接器
   											  |
   								        —————————————————
   								        |				|
   								        |				|
   		命中缓存直接返回结果 <-------    查询缓存	<-----  分析器	
   								      					|
   								      					|
   								      				  优化器
   								      				    |
   								      				    |
   								      				  执行器
   								      			|	  
   								      			|	  
   								      			|	  
   								      	     存储引擎
   ```

   

​	MySQL可以分为Server层和存储引擎层两部分：

- Server层：连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。

3. MySQL是如何执行一条SQL的？具体步骤有哪些？

- 客户端请求->
- 连接器（验证用户身份，给予权限） ->
- 查询缓存（存在缓存则直接返回，不存在则执行后续操作）->
- 分析器（对SQL进行词法分析和语法分析操作） ->
- 优化器（主要对执行的SQL优化选择最优的执行方案） ->
- 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）->
- 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

4. 什么是事务？

   所谓事务，它是一个**操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位**。（执行单个逻辑功能的一组指令或操作称为事务）

5. 事务的四大特性

- 原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

- 一致性：是指在**事务开始之前和事务结束以后**，**数据库的完整性约束没有被破坏**。这是说数据库事务不能破坏**关系数据的完整性**以及**业务逻辑上的一致性**。

  如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。

- 隔离性：**多个事务并发访问时，事务之间是隔离的**，一个事务不应该影响其它事务运行效果。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

- 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

6. 数据库并发事务会带来哪些问题？（事务并发一致性问题）

- 脏读（Dirty read）：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。

  例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。

- 丢失修改（Lost to modify）：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

  例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=100，事务 2 后来也修改 A=50，最终结果 A=17，事务 1 的修改被丢失。

- 不可重复读（Unrepeatable read）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

  例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。

- 幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

  例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。

7. 不可重复读和幻读有什么区别？

- 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；
- 幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

8. 事务的隔离级别

