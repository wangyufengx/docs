# JAVA 并发面试题整理

1. 进程、线程、协程

	- 进程是操作系统资源分配的基本单位，它包含了程序代码、数据以及运行时系统资源（如打开的文件、网络连接等），可以看作是一个独立的运行环境。进程之间相互独立，每个进程都有自己的地址空间、工作栈和其他操作系统资源。不同进程之间通信需要使用进程间通信机制（IPC）。

	- 线程是进程内的独立执行流，线程共享进程的地址空间和资源，但拥有自己的堆栈和寄存器。多个线程可以同时在同一个进程内执行不同的任务，它们之间可以通过共享内存等方式进行通信。

	- 协程是一种用户态的轻量级线程，也被称为“微线程”。协程不依赖于操作系统的调度，而是由用户程序自行管理调度，因此切换成本非常低。协程可以看作是一种特殊的子例程，不同的是它可以暂停执行，并且可以从上次暂停的位置继续执行。协程适用于高并发、高性能和复杂的应用场景，例如网络编程、Web框架等。

2. 并行与并发

	- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
	- **并行**：两个及两个以上的作业在同一 **时刻** 执行。

3. 同步与异步

	- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
	- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

4. 为什么要使用多线程

	使用多线程可以提高程序的并发性和响应能力，也可以充分利用计算机的多核处理器来提高程序的运行效率。在单线程情况下，当程序执行一个耗时的操作时，整个程序都会被阻塞，无法继续执行其他任务。而多线程可以使得多个任务同时执行，即使其中某些任务阻塞了，其他任务也仍然可以继续执行，从而提高了程序的并发性和响应能力。此外，如果程序需要进行一些并行计算，多线程也可以将这些计算任务分配到不同的线程上并行执行，从而显著提高程序的运行效率。

5. 使用多线程可能带来的问题？

	并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

6. 如何理解线程安全和不安全？

	线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

	- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
	- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

7. Java线程的生命周期和状态？

	Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

	- NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
	- RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
	- BLOCKED：阻塞状态，需要等待锁释放。
	- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
	- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
	- TERMINATED：终止状态，表示该线程已经运行完毕。

8. 什么是线程上下文切换？

	线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

	- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
	- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
	- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
	- 被终止或结束运行

	这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。

	上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

9. 产生死锁的必要条件

	- 互斥条件：该资源任意一个时刻只由一个线程占用。
	- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
	- 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
	- 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

10. 如何预防死锁

	- **破坏请求与保持条件**：一次性申请所有的资源。

	- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

	- **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

11. 如何避免死锁

	避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

12. sleep()方法和wait()方法对比

	**共同点**：两者都可以暂停线程的执行。

	**区别**：

	- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
	- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
	- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
	- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

13. 为什么 wait() 方法不定义在 Thread 中？

	`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

14. **为什么 `sleep()` 方法定义在 `Thread` 中？**

	因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

15. 可以直接调用 Thread 类的 run 方法吗？

	new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

	**总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

16. volatile作用

	**`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。**

17. 乐观锁

	乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。

	高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。

	不过，大量失败重试的问题也是可以解决的，像我们前面提到的 `LongAdder`以空间换时间的方式就解决了这个问题。

18. 悲观锁

	悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。（Java 中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。）

19. 如何实现乐观锁？

	乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。

	- 版本号机制：一般是在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新，否则重试更新操作，直到更新成功。

	- CAS算法：CAS 的全称是 **Compare And Swap（比较与交换）** ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

		CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。

		CAS 涉及到三个操作数：

		- **V**：要更新的变量值(Var)
		- **E**：预期值(Expected)
		- **N**：拟写入的新值(New)

		当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。

20. 乐观锁存在的问题？

	ABA 问题是乐观锁最常见的问题。

21. ABA问题

	如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 **"ABA"问题。**

	ABA 问题的解决思路是在变量前面追加上**版本号或者时间戳**。

22. synchronized的作用？

	`synchronized` 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

23. synchronized关键字的3种使用方式

	- **修饰实例方法** （锁当前对象实例）

		给当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁** 。

	```java
	synchronized void method() {
	    //业务代码
	}
	```

	- **修饰静态方法** （锁当前类）

	给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。

	这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。

	```java
	synchronized static void method() {
	    //业务代码
	}
	```

	静态 `synchronized` 方法和非静态 `synchronized` 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁。

	- **修饰代码块** （锁指定对象/类）

		对括号里指定的对象/类加锁：

		- `synchronized(object)` 表示进入同步代码库前要获得 **给定对象的锁**。
		-  `synchronized(类.class)` 表示进入同步代码前要获得 **给定 Class 的锁**

	```java
	synchronized(this) {
	    //业务代码
	}
	```

	**总结：**

	- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁；
	- `synchronized` 关键字加到实例方法上是给对象实例上锁；
	- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

24. 构造方法可以使用synchronized修饰么？

	**构造方法不能使用 synchronized 关键字修饰。**构造方法本身就属于线程安全的，不存在同步的构造方法一说。

25. synchronized 和 volatile 有什么区别？

	`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

	- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
	- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
	- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

26. 公平锁和非公平锁

	**公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。

	**非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

27. 自旋锁

28. 适应性自旋锁

29. 锁消除

30. 锁粗化

31. 偏向锁







## 参考文档

https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w