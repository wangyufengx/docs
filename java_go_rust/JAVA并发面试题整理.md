# JAVA 并发面试题整理

1. 进程、线程、协程

	- 进程是操作系统资源分配的基本单位，它包含了程序代码、数据以及运行时系统资源（如打开的文件、网络连接等），可以看作是一个独立的运行环境。进程之间相互独立，每个进程都有自己的地址空间、工作栈和其他操作系统资源。不同进程之间通信需要使用进程间通信机制（IPC）。

	- 线程是进程内的独立执行流，线程共享进程的地址空间和资源，但拥有自己的堆栈和寄存器。多个线程可以同时在同一个进程内执行不同的任务，它们之间可以通过共享内存等方式进行通信。

	- 协程是一种用户态的轻量级线程，也被称为“微线程”。协程不依赖于操作系统的调度，而是由用户程序自行管理调度，因此切换成本非常低。协程可以看作是一种特殊的子例程，不同的是它可以暂停执行，并且可以从上次暂停的位置继续执行。协程适用于高并发、高性能和复杂的应用场景，例如网络编程、Web框架等。

2. 并行与并发

	- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
	- **并行**：两个及两个以上的作业在同一 **时刻** 执行。

3. 同步与异步

	- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
	- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

4. 为什么要使用多线程

	使用多线程可以提高程序的并发性和响应能力，也可以充分利用计算机的多核处理器来提高程序的运行效率。在单线程情况下，当程序执行一个耗时的操作时，整个程序都会被阻塞，无法继续执行其他任务。而多线程可以使得多个任务同时执行，即使其中某些任务阻塞了，其他任务也仍然可以继续执行，从而提高了程序的并发性和响应能力。此外，如果程序需要进行一些并行计算，多线程也可以将这些计算任务分配到不同的线程上并行执行，从而显著提高程序的运行效率。

5. 使用多线程可能带来的问题？

	并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

6. 如何理解线程安全和不安全？

	线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

	- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
	- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

7. Java线程的生命周期和状态？

	Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

	- NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
	- RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
	- BLOCKED：阻塞状态，需要等待锁释放。
	- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
	- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
	- TERMINATED：终止状态，表示该线程已经运行完毕。

8. 什么是线程上下文切换？

	线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

	- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
	- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
	- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
	- 被终止或结束运行

	这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。

	上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

9. 产生死锁的必要条件

	- 互斥条件：该资源任意一个时刻只由一个线程占用。
	- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
	- 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
	- 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

10. 如何预防死锁

	- **破坏请求与保持条件**：一次性申请所有的资源。

	- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

	- **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

11. 如何避免死锁

	避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

12. sleep()方法和wait()方法对比

	**共同点**：两者都可以暂停线程的执行。

	**区别**：

	- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
	- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
	- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
	- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

13. 为什么 wait() 方法不定义在 Thread 中？

	`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

14. **为什么 `sleep()` 方法定义在 `Thread` 中？**

	因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

15. 可以直接调用 Thread 类的 run 方法吗？

	new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

	**总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

16. 







## 参考文档

https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w