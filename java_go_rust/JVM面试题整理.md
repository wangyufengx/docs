# JVM面试题整理

1. 什么是JVM?

	JVM（Java Virtual Machine）是一种能够解释并执行 Java 代码的虚拟机。它是 Java 平台的核心部分，可以在不同的操作系统和硬件平台上运行相同的 Java 程序。JVM 是一个抽象的计算机，在其上执行的 Java 代码被编译成字节码格式，然后由 JVM 解释执行。JVM 还提供了内存管理、垃圾回收、安全性控制等功能，使得 Java 程序可以自动管理内存并具有高度的可移植性和安全性。

2. JVM 有哪些组件？

	JVM 包含三个主要的组件：类加载器、运行时数据区和执行引擎。

	- 类加载器负责加载字节码文件并生成对应的 Java 类。
	- 运行时数据区包含了 JVM 中的各种内存区域，例如堆、栈、方法区等。
	- 执行引擎负责执行字节码文件，并将其转换成实际的机器指令。

3. Hotspot JVM 后台运行的系统线程主要有哪些？

	- 垃圾回收线程：负责对堆内存中的对象进行垃圾回收，释放不再使用的内存空间。
	- 编译器线程：负责即时编译字节码成本地代码，提高程序运行效率。
	- 信号分发线程：负责将操作系统发送的信号转换为Java虚拟机能够识别的异常，并交由相应的处理器处理。
	- 异常处理器线程：负责处理与Java虚拟机相关的异常，如线程死锁、资源耗尽等异常。
	- 定时器线程：负责触发周期性任务的执行，如java.util.Timer和java.util.concurrent.ScheduledThreadPoolExecutor类中所使用的定时器任务。
	- 监控线程：负责监控Java虚拟机的各种状态信息，如内存使用情况、线程运行状态等。
	- GC辅助线程：在执行全局垃圾回收时，负责协助完成一些必要的工作，如清理弱引用、清理SoftReference等。

## JVM运行时数据区域

1. Java虚拟机运行时数据区

	![](../img/java_runtime_data_area.png)

2. 程序计数器（线程私有）

	一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

	如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；

	如果正在执行的是Native方法，这个计数器值则为空。

	此内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。

3. 虚拟机栈（线程私有）

	描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

	每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

	生命周期与线程相同。

4. 本地方法栈（线程私有）

	和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

5. Java堆

	Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。

	**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

	Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

6. 方法区

	方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。

	《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。

	当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

7. 栈帧

	用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。

	栈帧包含了局部变量表、操作数栈、动态链接、方法返回地址等。

8. 局部变量表

	主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

9. 操作数栈

	主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

10. 动态链接

	主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。

11. 运行时常量池

	方法区的一部分。

	运行时常量池（Runtime Constant Pool）是在Java虚拟机（JVM）的内存中存储常量的一种数据结构。它包含了类文件中描述的各种类型的常量，例如字符串常量、数字常量、方法和字段引用、类和接口名等。

	在Java程序运行期间，通过运行时常量池中的符号引用来定位具体的内存地址，从而实现对常量的访问。这个过程称为解析。

	需要注意的是，运行时常量池是每个Class文件独有的，它与其他的Class文件共享的只是常量池中的常量引用。同时，运行时常量池也不一定是固定不变的，例如可以使用String.intern()方法将一个字符串对象添加到常量池中，或者通过反射和动态代理技术来修改常量池中的内容。

12. 字符串常量池

	**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

	字符串常量池（String Constant Pool）是运行时常量池中的一种特殊形式，用于存储Java程序中使用字面值方式创建的字符串对象。在Java中，当我们使用双引号定义一个字符串变量时，会首先检查字符串常量池中是否已经存在该字符串，如果已经存在，则直接返回该字符串的引用，否则创建一个新的字符串对象，并在字符串常量池中保存这个字符串。

13. 直接内存

	直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

	直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

## JVM垃圾收集

1. 判断一个对象是否可以被回收？

	- 引用计数法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
	- 可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

2. 哪些对象可以作为GC Roots？

	- 虚拟机栈中（栈帧的局部变量表中）引用的对象
	- 本地方法栈(Native 方法)中引用的对象
	- 方法区中类静态属性引用的对象
	- 方法区中的常量引用的对象
	- 所有被同步锁持有的对象

3. 如何判断一个类是无用的类？

	- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

		加载该类的 `ClassLoader` 已经被回收。

		该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

4. 方法区的回收

	因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

	主要是对常量池的回收和对类的卸载。

	为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

	虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

5. 四种引用类型

	- 强引用：被强引用关联的对象不会被回收。

		使用 new 一个新对象的方式来创建强引用。

		```java
		Object obj = new Object();
		```

	- 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。

		使用 SoftReference 类来创建软引用。

		```java
		Object obj = new Object();
		SoftReference<Object> sf = new SoftReference<Object>(obj);
		obj = null;  // 使对象只被软引用关联
		```

	- 弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

		使用 WeakReference 类来创建弱引用。

		```java
		Object obj = new Object();
		WeakReference<Object> wf = new WeakReference<Object>(obj);
		obj = null;
		```

	- 虚引用：又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

		为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

		使用 PhantomReference 来创建虚引用。

		```java
		Object obj = new Object();
		PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
		obj = null;
		```

6. 垃圾收集算法

	



## 内存分配与回收策略



## 类加载机制

1. Java 对象的创建过程可以具体分为以下几个步骤：

	- 检查类是否被加载

		在创建一个对象之前，JVM 需要先检查该对象所属的类是否已经被加载到内存中。如果没有被加载，JVM 会根据需要从磁盘上读取类文件，并进行加载和链接。

	- 分配内存空间

		当类被加载后，JVM 会为该类的对象分配一块连续的内存空间。在分配内存空间时，JVM 会根据对象的大小以及 JVM 的内存分配策略来确定对象在内存中的实际位置。

	- 初始化对象头

		在分配内存空间后，JVM 会对对象头进行一些初始化操作。对象头是每个 Java 对象都有的固定字节长度的数据结构，它包含了很多元数据信息，比如对象的类型、哈希码、锁状态等信息。

	- 执行构造方法

		在对象头初始化完成后，接下来就是执行构造方法的过程。构造方法是类中特殊的方法，用于对对象进行初始化操作。在执行构造方法时，会对对象的属性进行赋值，并进行其他必要的初始化工作。

	- 返回对象引用
	- 当对象初始化完成后，JVM 会返回对象在堆内存中的地址值，这个地址值就是对象的引用，可以用来访问对象的属性和方法。

	总的来说，Java 对象的创建过程包括检查类是否被加载、分配内存空间、初始化对象头、执行构造方法和返回对象引用这几个步骤。这个过程是比较复杂的，需要考虑多种因素，比如类的大小、内存分配策略、构造方法的实现等等。但是，Java 对象的创建过程是 Java 程序的基础，也是保证程序正确性和性能的重要环节。









## 参考资料

https://javaguide.cn/java/jvm/memory-area.html

深入理解Java虚拟机

