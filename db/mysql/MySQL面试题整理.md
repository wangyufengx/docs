# MySQL面试题整理

[TOC]

## 数据库基础知识

1. **数据库三大范式**

  - 第一范式： 每一列（属性）都不可再分。（原子性）

  - 第二范式： 在第一范式的基础上，非主属性非部分依赖于主属性。（换句话说，第一范式消除了非主属性对主属性的部分函数依赖的就是第二范式）

  - 第三范式： 在第二范式的基础上，属性不依赖于其他非主属性。（换句话说，第二范式消除了非主属性对主属性的传递函数依赖的就是第三范式）
2. **drop、delete 与 truncate 区别**
	- `drop`(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
	- `truncate` (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
	- `delete`（删除数据） : `delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where` 子句和`truncate table 表名`作用类似。
3. **DML 语句和 DDL 语句区别：**
	- DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。
	- DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。





## MySQL基础架构

1. **MySQL逻辑架构**

```
											客户端
											  |
											  |
											  |
											连接器
											  |
								        —————————————————
								        |				|
								        |				|
		命中缓存直接返回结果 <-------    查询缓存	<-----  分析器	
								      					|
								      					|
								      				  优化器
								      				    |
								      				    |
								      				  执行器
								      			|	  
								      			|	  
								      			|	  
								      	     存储引擎
```

​		MySQL可以分为Server层和存储引擎层两部分：

- Server层：连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。

2. **MySQL是如何执行一条SQL的？具体步骤有哪些？**

- 客户端请求->
- 连接器（验证用户身份，给予权限） ->
- 查询缓存（存在缓存则直接返回，不存在则执行后续操作）->
- 分析器（对SQL进行词法分析和语法分析操作） ->
- 优化器（主要对执行的SQL优化选择最优的执行方案） ->
- 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）->
- 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

## MySQL引擎

1. **MyISAM和InnoDB有什么区别？**

- InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。

- MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。

- MyISAM 不支持外键，而 InnoDB 支持。

- MyISAM 不支持 MVCC，而 InnoDB 支持。

- 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

- MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。

- InnoDB 的性能比 MyISAM 更强大。

 ## Mysql数据字段类型

1.  **MySQL中DATETIME和TIMESTAMP的区别**
	- DATETIME 的日期范围是 1001——9999 年；TIMESTAMP 的时间范围是 1970——2038 年
	- DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区
	- DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节
	- DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)
	
2.  **MySQL中CHAR和VARCHAR的区别有哪些？**
	- char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。
	- char的存取数度还是要比varchar要快得多
	- char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。



## MySQL事务

1. **什么是事务？**

	 所谓事务，它是一个**操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位**。（执行单个逻辑功能的一组指令或操作称为事务）

2. **事务的四大特性**

	  - 原子性：是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

	  - 一致性：是指在**事务开始之前和事务结束以后**，**数据库的完整性约束没有被破坏**。这是说数据库事务不能破坏**关系数据的完整性**以及**业务逻辑上的一致性**。如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变。

	  - 隔离性：**多个事务并发访问时，事务之间是隔离的**，一个事务不应该影响其它事务运行效果。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

	  - 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。


3. **数据库并发事务会带来哪些问题？（事务并发一致性问题）**

	- 脏读（Dirty read）：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。

	  例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。
	  
	- 丢失修改（Lost to modify）：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
	
	    例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=100，事务 2 后来也修改 A=50，最终结果 A=17，事务 1 的修改被丢失。
	
	- 不可重复读（Unrepeatable read）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
	
	    例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。
	
	- 幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
	
	    例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。


4. **不可重复读和幻读有什么区别？**

	- 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；

	- 幻读的重点在于记录新增比如多次执行同一条查询语句时，发现查到的记录增加了。


5. **事务的隔离级别**

	- **READ-UNCOMMITTED(读取未提交)** ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 

	- **READ-COMMITTED(读取已提交)** ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

	- **REPEATABLE-READ(可重复读)** ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

		引申：现在主流数据库都使用 MVCC 并发控制，使用之后RR（可重复读）隔离级别下是不会出现幻读的现象。

	- **SERIALIZABLE(可串行化)** ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
	
		|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
		| :--------------: | :--: | :--------: | :--: |
		| READ-UNCOMMITTED |  √   |     √      |  √   |
		|  READ-COMMITTED  |  ×   |     √      |  √   |
		| REPEATABLE-READ  |  ×   |     ×      |  √   |
		|   SERIALIZABLE   |  ×   |     ×      |  ×   |
	
		MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ**（可重读）。它是可以解决幻读问题发生的，主要有下面两种情况：
	
		- **快照读** ：由 MVCC 机制来保证不出现幻读。
		- **当前读** ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。

6. **什么是MVCC ?**
	**MVCC**，全称 **`Multi-Version Concurrency Control`** ，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
	
	**MVCC** 在 **MySQL InnoDB** 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。
	
	**说白了 MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**。

7. **什么是当前读和快照读？**

	- 当前读：像 select lock in share mode (**共享锁**), select for update; update; insert; delete (**排他锁**)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时会保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
	- 快照读：像**不加锁**的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。


8. **并发事务的控制方式？**

  MySQL 中并发事务的控制方式无非就两种：**锁** 和 **MVCC**。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。

  **锁** 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 **读写锁** 来实现并发控制。

  - **共享锁（S 锁）** ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
  - **排他锁（X 锁）** ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。

  读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 **表级锁(table-level locking)** 和 **行级锁(row-level locking)** 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。

  **MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

  MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。

  - undo log : undo log 用于记录某行数据的多个版本的数据。
  - read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

9. **MySQL 的隔离级别是基于锁实现的吗？**

  MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。

  SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。

10. **Innodb的事务实现原理**

  - 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。
  - 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。
  - 隔离性：通过锁以及MVCC,使事务相互隔离开。
  - 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。

## MySQL索引

1. **索引的优点**

  - 创建唯一性索引，保证数据库表中每一行数据的唯一性
  - 大大加快数据的检索速度，这是创建索引的最主要的原因
  - 加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义
  - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
  - 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能

2. **索引的缺点**

  - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
  - 索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大
  - 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

3. **主键索引**

  数据表的主键列使用的就是主键索引。

  一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

  在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

4. **唯一索引(Unique Key)** 

  唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

5. **普通索引(Index)** 

  **普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**

6. **前缀索引(Prefix)** 

  前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。

7. **全文索引(Full Text)** 

  全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

8. **聚簇索引**

  **聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。**

  **优点**：

  - **查询速度非常快** ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。
  -  聚簇索引对于主键的排序查找和范围查找速度非常快。

  **缺点**：

  - 插入速度严重依赖于插入顺序，按照主键的**顺序插入**是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的ID列为主键**
  - **更新主键的代价很高**，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
  - 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

9. **非聚簇索引**

  **非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。**

  非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据

  **优点** ：

  - 更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的

  **缺点** ：

  - **依赖于有序的数据** ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据
  - **可能会二次查询(回表)** ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

10.  **选择合适的字段创建索引**

	- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
	- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
	- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
	- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
	- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

11.  **导致索引失效的情况**

	- 在索引列上进行计算、函数、类型转换等操作;
	- 如果MySQL估计使用**全表扫秒比使用索引快**，则不使用索引。
	- 创建了组合索引，但查询条件未遵守最左匹配原则;
	- 以 `%` 开头的 LIKE 查询比如 `like '%abc'`;会导致全表扫描。
	- 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
	- 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
	- 隐式转换。

12.  **隐式转换**

	当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字。

	- 当操作符**左右两边的数据类型不一致**时，会发生**隐式转换**。
	- 当 where 查询操作符**左边为数值类型**时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。
	- 当 where 查询操作符**左边为字符类型**时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。
	- 字符串转换为数值类型时，非数字开头的字符串会转化为`0`，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。

13.  **比较操作的转换方式**

	- 两个参数至少有一个是`NULL`时，比较的结果也是`NULL`，特殊的情况是使用`<=>`对两个`NULL`做比较时会返回`1`，这两种情况都不需要做类型转换

	- 两个参数都是字符串，会按照字符串来比较，不做类型转换

	- 两个参数都是整数，按照整数来比较，不做类型转换

	- 十六进制的值和非数字做比较时，会被当做二进制串

	- 有一个参数是`TIMESTAMP`或`DATETIME`，并且另外一个参数是常量，常量会被转换为`timestamp`

	- 有一个参数是`decimal`类型，如果另外一个参数是`decimal`或者整数，会将整数转换为`decimal`后进行比较，如果另外一个参数是浮点数，则会把`decimal`转换为浮点数进行比较。浮点数>decimal>整数。

	- **所有其他情况下，两个参数都会被转换为浮点数再进行比较**

		- **不以数字开头**的字符串都将转换为`0`。如`'abc'`、`'a123bc'`、`'abc123'`都会转化为`0`；
		- **以数字开头的**字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如`'123abc'`会转换为`123`，`'012abc'`会转换为`012`也就是`12`，`'5.3a66b78c'`会转换为`5.3`，其他同理。

		

## MySQL锁

1. **表级锁和行级锁的区别**

  - **表级锁：** MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
  - **行级锁：** MySQL 中锁定粒度最小的一种锁，是 **针对索引字段加的锁** ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。

2. **行级锁使用的注意事项**

  InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 `UPDATE`、`DELETE` 语句时，如果 `WHERE`条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。

  很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。

3. **死锁的四个必要条件**

  - 互斥条件：一个资源每次只能被一个进程使用。

  - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
  - 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
  - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。




## MySQL日志

1. MySQL 中常见的日志有哪些？

	  - 归档日志：二进制日志 `binlog`

	  - 重做日志：事务日志 `redo log`

	  - 回滚日志：`undo log`

	  - 错误日志

	  - 查询日志

	  - 慢查询日志

2. binlog 主要记录了什么？

	binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。

3. redo log 如何保证事务的持久性？

	redo log 是物理日志，记录了某个数据页做了什么修改，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**，每当执行一个事务就会产生这样的一条或者多条物理日志。

	在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。

	当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。

4. binlog 和 redolog 有什么区别？

  - *适用对象不同：*

  	- binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；

  	- redo log 是 Innodb 存储引擎实现的日志；

  - *文件格式不同：*

  	- binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：
        		- STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；
        		- ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；
        		- MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；

  	- redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；

  - *写入方式不同：*

  	- binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。

  	- redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。

  - *用途不同：*

  	- binlog 用于备份恢复、主从复制；
  	- redo log 用于掉电等故障恢复。

5. undo log 如何保证事务的原子性？

	undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚

6. **主从复制步骤**

	- 主库的更新事件(update、insert、delete)被写到binlog
	- 从库发起连接，连接到主库。
	- 此时主库创建一个binlog dump thread，把binlog的内容发送到从库。
	- 从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
	- 还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db。

7. **主从复制原理**

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。



## MySQL优化

1.  一条sql执行过长的时间，你如何优化，从哪些方面入手？

	- 查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等
	- 优化索引结构，看是否可以适当添加索引
	- 数量大的表，可以考虑进行分离/分表（如交易流水表）
	- 数据库主从分离，读写分离
	- explain分析sql语句，查看执行计划，优化sql。
	- 使用select 具体字段代替 select  \*，使用count(*) 而不是count(列名)。
	- 查看mysql执行日志，分析是否有其他方面的问题。

2.  **count(1)、count(*) 与 count(列名) 的区别**

	- count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL
	- count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL
	- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。

3. **主键使用自增ID还是UUID，为什么？**

  如果是单机的话，选择自增ID；如果是分布式系统，优先考虑UUID吧，但还是最好自己公司有一套分布式唯一ID生产方案吧。

  - 自增ID：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能有问题。
  - uuid：适合大量数据的插入和更新操作，但是它无序的，插入数据效率慢，占用空间大。

4. **MySQL自增主键不连续的 4 个场景：**

  - 自增初始值和自增步长设置不为 1
  - 唯一键冲突
  - 事务回滚
  - 批量插入（如 `insert...select` 语句）

## 参考资料

https://github.com/wangyufengx/fullstack-tutorial/blob/master/notes/MySQL.md

https://github.com/lifei6671/interview-go/blob/master/mysql/mysql-interview.md

https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md

https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html

https://javaguide.cn/database/mysql/mysql-questions-01.html

https://xiaolincoding.com/mysql/

https://lilu.org.cn/library
