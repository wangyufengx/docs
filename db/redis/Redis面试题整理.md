# Redis面试题整理



1. **3种常用的缓存读写策略**

  - Cache-Aside（旁路缓存）：Cache-Aside是最常用的缓存读写策略之一，也被称为“Lazy Loading”。

	读步骤：

	- 当需要获取数据时，先检查缓存中是否存在该数据，如果存在，则直接从缓存中获取数据返回；
	- 如果缓存中不存在该数据，则从数据库（如MySQL）中读取数据；
	- 然后将数据写入缓存中，以便下次读取时可以直接从缓存中获取。

	写步骤：

	- 先写入数据库，再删除Redis缓存。

	优点：

	- 简单易用，容易实现。
	- 缓存与数据库完全分离，不会对数据库造成任何负担。

	缺点：

	- 数据库和缓存之间可能存在数据不一致的问题，特别是在高并发环境下。
	- 如果缓存中的数据过期或被删除，会导致缓存穿透问题。

  - Read/Write Through（读写穿透）：Read/Write Through是一种较为保守的缓存读写策略

	读步骤：

	- 当从缓存中读取数据时，先检查缓存中是否存在该数据，如果存在，则直接从缓存中获取数据返回；
	- 如果缓存中不存在该数据，则从数据库中读取数据，并将数据写入缓存中，以便下次读取时可以直接从缓存中获取。

	写步骤：

	- 在数据更新时，Redis缓存中不存在时直接写入数据库。
	- Redis缓存存在时先更新缓存，然后Redis缓存自己更新数据库。

	优点：

	- 数据库和缓存之间保持一致，减少数据不一致的可能性。
	- 数据更新时先将数据写入缓存，减少数据库的压力。

	缺点：

	- 写操作需要同时写入缓存和数据库，相对于只写入数据库来说，增加了写入成本。

  - Write Behind（异步缓存写入）：一种较为激进的缓存读写策略。其核心思想是在数据更新时，仅将数据写入缓存，而不立即写入数据库。

	读步骤：

	- 从缓存中读取数据时，先检查缓存中是否存在该数据，如果存在，则直接从缓存中获取数据返回；
	- 如果缓存中不存在该数据，则从数据库中读取数据，并将数据写入缓存中，以便下次读取时可以直接从缓存中获取。

	写步骤：

	- 当缓存中的数据被修改时，会先将修改后的数据写入缓存，然后再定期将缓存中的数据批量写入到数据库中。

	优点：

	- 写操作只需要写入缓存，相对于同时写入缓存和数据库来说，大大减少了写入成本。
	- 定期将缓存中的数据批量写入数据库，可以保证数据的可靠性，避免数据丢失。

	缺点：

	- 在高并发环境下，缓存中的数据可能存在较长时间的不一致，对数据的可靠性有一定影响。
	- 写操作只写入缓存，可能会导致数据库中的数据与缓存中的数据不一致。比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。

	消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。

	Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。

2. **什么是Redis?**

	Redis(Remote Dictionary Server) Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API 的非关系型数据库。

	与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。

3. **Redis为什么这么快？**

	- 纯内存操作：Redis 将所有数据存储在内存中，避免了磁盘 I/O 的开销，使得 Redis 能够快速读写数据。
	- 单线程模型：Redis 使用单线程模型，避免了多线程之间的锁竞争和上下文切换等开销，并且可以避免并发问题，使得 Redis 在高并发场景下表现出色。
	- 高效的数据结构和算法：Redis 内置了各种高效的数据结构和算法，例如哈希表、跳表、布隆过滤器等，在对数据进行存储和操作时非常高效。
	- 异步 I/O：Redis 使用异步 I/O 模型，能够快速响应客户端请求，同时减少服务器资源占用。

4. **Redis支持的数据类型**

	Redis 可以存储键和不同类型的值之间的映射。键的类型只能为字符串，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。

	  - **String字符串**：

		格式: set key value

		string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

		string类型是Redis最基本的数据类型，一个键最大能存储512MB。

		应用场景：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。

	  - **Hash（哈希）**

		格式: hmset name key1 value1 key2 value2

		Redis hash 是一个键值(key=>value)对集合。

		Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

		应用场景：存储用户信息，商品信息等。

	  - **List（列表）**

		Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

		格式: lpush name value

		在 key 对应 list 的头部添加字符串元素

		格式: rpush name value

		在 key 对应 list 的尾部添加字符串元素

		格式: lrem name index

		key 对应 list 中删除 count 个和 value 相同的元素

		格式: llen name

		返回 key 对应 list 的长度

		应用场景：最新文章、最新动态。

	  - **Set（集合）**

		格式: sadd name value

		Redis的Set是string类型的无序集合。

		集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

		应用场景：共同关注、共同粉丝、共同喜好等

	  - **zset(sorted set：有序集合)**

		格式: zadd name score value

		Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。

		不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

		zset的成员是唯一的,但分数(score)却可以重复。

		应用场景：如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息。






## Redis持久化

1. 什么是Redis持久化？Redis有哪几种持久化方式？

  持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

  Redis 提供了三种持久化方式:RDB（默认） 、AOF、RDB和AOF混合持久化

  - 快照（snapshotting，RDB）：是指将Redis在内存中的数据以快照的形式写入到磁盘中，从而实现数据持久化的目的。

	在RDB持久化机制下，当满足一定条件时（例如save操作或者自定义的触发条件），Redis会将当前内存中的数据以快照的形式写入到磁盘上的一个文件中。这个过程中，Redis会先fork出一个子进程来负责生成快照，然后主进程就可以继续处理新的请求了。在生成快照的过程中，子进程会将当前内存中的数据写入到一个临时文件中，完成后再替换原有的快照文件。

	在使用RDB持久化机制时，我们可以通过配置文件中的相关选项设置自动保存的时间间隔和手动保存的命令。比如，以下配置选项表示每900秒至少有1个key发生变化，则自动执行RDB持久化操作：

	```conf
	Copy Codesave 900 1
	```

  - 只追加文件（append-only file, AOF）:是一种将Redis执行的写操作以追加方式写入到磁盘中的方法。它会将每个写命令写入到一个文件末尾，以此来记录服务器所接收到的所有修改操作，包括添加、删除、更新等。

	当需要对数据进行持久化时，Redis会将AOF缓冲区中的内容写入到磁盘文件中，从而保证数据的持久化。AOF文件是一个文本文件，可以通过简单的文本编辑器进行查看和修改。

	AOF持久化机制有两种同步方式：每秒钟同步一次（默认方式），或每次写操作都同步一次。前者可以提高性能，但在发生故障时可能会丢失1秒钟的数据，而后者可以保证数据的完整性，但会降低性能。

	在Redis重启时，可以通过加载AOF文件来恢复数据。如果同时开启了AOF和RDB持久化机制，Redis会优先使用AOF文件来进行数据的恢复。

  - RDB 和 AOF 的混合持久化(Redis 4.0 新增)：将RDB和AOF混合使用可以提供更可靠的持久化机制（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。

	如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

	同时，Redis还可以配置在每次执行写命令时自动进行快照（即自动执行BGSAVE命令），以便在出现故障时能够快速恢复数据。

2. RDB与AOF比较

  | RDB持久化                                                    | AOF持久化                                    |
  | ------------------------------------------------------------ | -------------------------------------------- |
  | 全量备份，一次保存整个数据库。                               | 增量备份，一次只保存一个修改数据库的命令。   |
  | 每次执行持久化操作的间隔时间较长。                           | 保存的间隔默认为一秒钟（Everysec）           |
  | 数据保存为二进制格式，其还原速度快。                         | 使用文本格式还原数据，所以数据还原速度一般。 |
  | 执行 SAVE 命令时会阻塞服务器，但手动或者自动触发的 BGSAVE 不会阻塞服务器 | AOF持久化无论何时都不会阻塞服务器。          |

3. RDB持久化出发方式

	- 手动触发：手动触发持久化的操作有两个： `save` 和 `bgsave` ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。

		- save 命令：在客户端中执行 `save` 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以**在生产环境一定要慎用**。
		- bgsave命令：bgsave（background save）既后台保存的意思， 它和 `save` 命令最大的区别就是 `bgsave` 会 fork() 一个子进程来执行持久化，整个过程中只有在 fork() 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 `save` 命令来说，显然 `bgsave` 命令更适合我们使用。

	- 自动触发：

		- save m n：是指在 m 秒内，如果有 n 个键发生改变，则自动触发持久化。 参数 m 和 n 可以在 Redis 的配置文件中找到，例如，`save 60 1` 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 `bgsave` 命令。 注意：当设置多个 save m n 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 save m n 命令：

			- save 60 10
			- save 600 1

			当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化；

		- flushall：命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 `flushall` 命令之后，则会触发自动持久化，把 RDB 文件清空；

		- 主动同步触发：在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 `bgsave` 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化；

		- 执行 debug reload 时；

		- 执行 shutdown时，如果没有开启aof，也会触发。

4. RDB优缺点

	优点是存储文件小，Redis启动时恢复数据比较快，缺点是有丢失数据的风险。

5. AOF持久化策略

	- always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；
	- everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；
	- no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。

6. AOF持久化方式

	- 手动触发：在客户端执行 `bgrewriteaof` 命令。
	- 自动触发：**满足 AOF 设置的策略触发**和**满足 AOF 重写触发**。

7. 为什么AOF文件要重写？

	AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。

8. 什么是AOF 重写？

	AOF重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。

	AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。

	在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。 为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。 重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。 AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。

9. AOF如何触发重写？

	- 手动触发：执行`BGREWRITEAOF`命令.
	- 自动触发：
		- `auto-aof-rewrite-min-size` ：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;
		- `auto-aof-rewrite-percentage`：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。

10. 持久化文件加载规则

	- 如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；
	- 如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；
	- 如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。

	在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 

11. 异常数据恢复

	- 简单异常数据恢复：在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。

		在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 `aof-load-truncated` 等于 `yes` 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis。

	- 复杂异常数据恢复：AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行。出现此类问题的解决方案如下：

		- 首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 `redis-check-aof` 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；
		- 如果无法手动修复，我们可以使用 `redis-check-aof --fix` 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。

12. AOF优缺点

	AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大。

13. 

## Redis数据

1. Redis数据淘汰策略

	- **noeviction（不淘汰）**：当内存不足以容纳新写入数据时，新写入操作会报错，提示写入失败。
	- **allkeys-lru（最近最少使用）**：从所有key中选取最近最少使用的数据淘汰。
	- **volatile-lru(过期键最近最少使用)**：从设置了过期时间的key中选择最近最少使用的数据淘汰。
	- **allkeys-random（随机淘汰）**：从所有key中随机选择数据淘汰。
	- **volatile-random(过期键随机淘汰)**：从设置了过期时间的key中随机选择数据淘汰。
	- **volatile-ttl（过期时间最短）**：从设置了过期时间的key中选择即将过期的数据淘汰。

	默认的淘汰策略为`volatile-lru`。可以通过修改配置文件或者动态修改参数来改变淘汰策略。例如，使用命令`CONFIG SET maxmemory-policy allkeys-random`来将淘汰策略修改为随机淘汰。

## Redis集群

1. 什么是 Sentinel？ 有什么用？

2. Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?

3. Sentinel 是如何实现故障转移的？

4. 为什么建议部署多个 sentinel 节点（哨兵集群）？

5. Sentinel 如何选择出新的 master（选举机制）?

6. 如何从 Sentinel 集群中选择出 Leader ？

7. Sentinel 可以防止脑裂吗？

8. 为什么需要 Redis Cluster？解决了什么问题？有什么优势？

9. Redis Cluster 是如何分片的？

10. 为什么 Redis Cluster 的哈希槽是 16384 个?

11. 如何确定给定 key 的应该分布到哪个哈希槽中？

12. Redis Cluster 支持重新分配哈希槽吗？

13. Redis Cluster 扩容缩容期间可以提供服务吗？

14. Redis Cluster 中的节点是怎么进行通信的？

	







## Redis生产问题

1. 缓存穿透：缓存穿透说简单点就是大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中** 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

	解决办法：

	- 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

	- **缓存无效 key**：如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： `SET key value EX 10086` 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。

	- **布隆过滤器**：布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。

		具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

		需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

2. 缓存击穿：请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

	解决办法：

	- 设置热点数据永不过期或者过期时间比较长。
	- 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
	- 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

3. 缓存雪崩：**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。**

	解决办法：

	- **针对 Redis 服务不可用的情况：**
		- 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
		- 限流，避免同时处理大量的请求。
	- **针对热点缓存失效的情况：**
		- 设置不同的失效时间比如随机设置缓存的失效时间。
		- 缓存永不失效（不太推荐，实用性太差）。
		- 设置二级缓存。

4. 缓存穿透和缓存击穿有什么区别？

	缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。

	缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。

5. 缓存雪崩和缓存击穿有什么区别？

	缓存雪崩导致的原因是缓存中的大量或者所有数据失效；

	缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。