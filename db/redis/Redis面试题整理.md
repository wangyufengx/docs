# Redis面试题整理



1. **3种常用的缓存读写策略**

  - Cache-Aside（旁路缓存）：Cache-Aside是最常用的缓存读写策略之一，也被称为“Lazy Loading”。

  	读步骤：

  	- 当需要获取数据时，先检查缓存中是否存在该数据，如果存在，则直接从缓存中获取数据返回；
  	- 如果缓存中不存在该数据，则从数据库（如MySQL）中读取数据；
  	- 然后将数据写入缓存中，以便下次读取时可以直接从缓存中获取。

  	写步骤：

  	- 先写入数据库，再删除Redis缓存。

  	优点：

  	- 简单易用，容易实现。
  	- 缓存与数据库完全分离，不会对数据库造成任何负担。

  	缺点：

  	- 数据库和缓存之间可能存在数据不一致的问题，特别是在高并发环境下。
  	- 如果缓存中的数据过期或被删除，会导致缓存穿透问题。

  - Read/Write Through（读写穿透）：Read/Write Through是一种较为保守的缓存读写策略，其核心思想是

  	读步骤：

  	- 当从缓存中读取数据时，先检查缓存中是否存在该数据，如果存在，则直接从缓存中获取数据返回；
  	- 如果缓存中不存在该数据，则从数据库中读取数据，并将数据写入缓存中，以便下次读取时可以直接从缓存中获取。

  	写步骤：

  	- 在数据更新时，Redis缓存中不存在时直接写入数据库。
  	- Redis缓存存在时先更新缓存，然后Redis缓存自己更新数据库。

  	优点：

  	- 数据库和缓存之间保持一致，减少数据不一致的可能性。
  	- 数据更新时先将数据写入缓存，减少数据库的压力。

  	缺点：

  	- 写操作需要同时写入缓存和数据库，相对于只写入数据库来说，增加了写入成本。

  - Write Behind（异步缓存写入）：一种较为激进的缓存读写策略。其核心思想是在数据更新时，仅将数据写入缓存，而不立即写入数据库。

  	读步骤：

  	- 从缓存中读取数据时，先检查缓存中是否存在该数据，如果存在，则直接从缓存中获取数据返回；
  	- 如果缓存中不存在该数据，则从数据库中读取数据，并将数据写入缓存中，以便下次读取时可以直接从缓存中获取。

  	写步骤：

  	- 当缓存中的数据被修改时，会先将修改后的数据写入缓存，然后再定期将缓存中的数据批量写入到数据库中。

  	优点：

  	- 写操作只需要写入缓存，相对于同时写入缓存和数据库来说，大大减少了写入成本。
  	- 定期将缓存中的数据批量写入数据库，可以保证数据的可靠性，避免数据丢失。

  	缺点：

  	- 在高并发环境下，缓存中的数据可能存在较长时间的不一致，对数据的可靠性有一定影响。
  	- 写操作只写入缓存，可能会导致数据库中的数据与缓存中的数据不一致。比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。

  	消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。

  	Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。

2. **什么是Redis?**

  Redis(Remote Dictionary Server) Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API 的非关系型数据库。

  与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。

3. **Redis支持的数据类型**

  Redis 可以存储键和不同类型的值之间的映射。键的类型只能为字符串，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。

  - **String字符串**：

  	格式: set key value

  	string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

  	string类型是Redis最基本的数据类型，一个键最大能存储512MB。

  	应用场景：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。

  - **Hash（哈希）**

  	格式: hmset name key1 value1 key2 value2

  	Redis hash 是一个键值(key=>value)对集合。

  	Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

  	应用场景：存储用户信息，商品信息等。

  - **List（列表）**

  	Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

  	格式: lpush name value

  	在 key 对应 list 的头部添加字符串元素

  	格式: rpush name value

  	在 key 对应 list 的尾部添加字符串元素

  	格式: lrem name index

  	key 对应 list 中删除 count 个和 value 相同的元素

  	格式: llen name

  	返回 key 对应 list 的长度

  	应用场景：最新文章、最新动态。

  - **Set（集合）**

  	格式: sadd name value

  	Redis的Set是string类型的无序集合。

  	集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

  	应用场景：共同关注、共同粉丝、共同喜好等

  - **zset(sorted set：有序集合)**

  	格式: zadd name score value

  	Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。

  	不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

  	zset的成员是唯一的,但分数(score)却可以重复。

  	应用场景：如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息。





## Redis持久化

1. 什么是Redis持久化？Redis有哪几种持久化方式？

  持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

  Redis 提供了三种持久化方式:RDB（默认） 、AOF、RDB和AOF混合持久化

  - 快照（snapshotting，RDB）：是指将Redis在内存中的数据以快照的形式写入到磁盘中，从而实现数据持久化的目的。

  	在RDB持久化机制下，当满足一定条件时（例如save操作或者自定义的触发条件），Redis会将当前内存中的数据以快照的形式写入到磁盘上的一个文件中。这个过程中，Redis会先fork出一个子进程来负责生成快照，然后主进程就可以继续处理新的请求了。在生成快照的过程中，子进程会将当前内存中的数据写入到一个临时文件中，完成后再替换原有的快照文件。

  	在使用RDB持久化机制时，我们可以通过配置文件中的相关选项设置自动保存的时间间隔和手动保存的命令。比如，以下配置选项表示每900秒至少有1个key发生变化，则自动执行RDB持久化操作：

  	```conf
  	Copy Codesave 900 1
  	```

  - 只追加文件（append-only file, AOF）:是一种将Redis执行的写操作以追加方式写入到磁盘中的方法。它会将每个写命令写入到一个文件末尾，以此来记录服务器所接收到的所有修改操作，包括添加、删除、更新等。

  	当需要对数据进行持久化时，Redis会将AOF缓冲区中的内容写入到磁盘文件中，从而保证数据的持久化。AOF文件是一个文本文件，可以通过简单的文本编辑器进行查看和修改。

  	AOF持久化机制有两种同步方式：每秒钟同步一次（默认方式），或每次写操作都同步一次。前者可以提高性能，但在发生故障时可能会丢失1秒钟的数据，而后者可以保证数据的完整性，但会降低性能。

  	在Redis重启时，可以通过加载AOF文件来恢复数据。如果同时开启了AOF和RDB持久化机制，Redis会优先使用AOF文件来进行数据的恢复。

  - RDB 和 AOF 的混合持久化(Redis 4.0 新增)：将RDB和AOF混合使用可以提供更可靠的持久化机制（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。

  	如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

  	同时，Redis还可以配置在每次执行写命令时自动进行快照（即自动执行BGSAVE命令），以便在出现故障时能够快速恢复数据。

  	

2. RDB与AOF比较

  | RDB持久化                                                    | AOF持久化                                    |
  | ------------------------------------------------------------ | -------------------------------------------- |
  | 全量备份，一次保存整个数据库。                               | 增量备份，一次只保存一个修改数据库的命令。   |
  | 每次执行持久化操作的间隔时间较长。                           | 保存的间隔默认为一秒钟（Everysec）           |
  | 数据保存为二进制格式，其还原速度快。                         | 使用文本格式还原数据，所以数据还原速度一般。 |
  | 执行 SAVE 命令时会阻塞服务器，但手动或者自动触发的 BGSAVE 不会阻塞服务器 | AOF持久化无论何时都不会阻塞服务器。          |

​		



1. Redis数据淘汰策略

	- **noeviction（不淘汰）**：当内存不足以容纳新写入数据时，新写入操作会报错，提示写入失败。
	- **allkeys-lru（最近最少使用）**：从所有key中选取最近最少使用的数据淘汰。
	- **volatile-lru(过期键最近最少使用)**：从设置了过期时间的key中选择最近最少使用的数据淘汰。
	- **allkeys-random（随机淘汰）**：从所有key中随机选择数据淘汰。
	- **volatile-random(过期键随机淘汰)**：从设置了过期时间的key中随机选择数据淘汰。
	- **volatile-ttl（过期时间最短）**：从设置了过期时间的key中选择即将过期的数据淘汰。

	默认的淘汰策略为`volatile-lru`。可以通过修改配置文件或者动态修改参数来改变淘汰策略。例如，使用命令`CONFIG SET maxmemory-policy allkeys-random`来将淘汰策略修改为随机淘汰。





## Redis生产问题

1. 缓存穿透：缓存穿透说简单点就是大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中** 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

	解决办法：

	- 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

	- **缓存无效 key**：如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： `SET key value EX 10086` 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。

	- **布隆过滤器**：布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。

		具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

		需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

2. 缓存击穿：请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

	解决办法：

	- 设置热点数据永不过期或者过期时间比较长。
	- 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
	- 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

3. 缓存雪崩：**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。**

	解决办法：

	- **针对 Redis 服务不可用的情况：**
		- 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
		- 限流，避免同时处理大量的请求。
	- **针对热点缓存失效的情况：**
		- 设置不同的失效时间比如随机设置缓存的失效时间。
		- 缓存永不失效（不太推荐，实用性太差）。
		- 设置二级缓存。

4. 缓存穿透和缓存击穿有什么区别？

	缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。

	缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。

5. 缓存雪崩和缓存击穿有什么区别？

	缓存雪崩导致的原因是缓存中的大量或者所有数据失效；

	缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。